"""
문제
5×5 크기의 숫자판이 있다. 
각각의 칸에는 숫자(digit, 0부터 9까지)가 적혀 있다. 

이 숫자판의 임의의 위치에서 시작해서, 
인접해 있는 네 방향으로 다섯 번 이동하면서, 
각 칸에 적혀있는 숫자를 차례로 붙이면 6자리의 수가 된다. 

이동을 할 때에는 한 번 거쳤던 칸을 다시 거쳐도 되며, 0으로 시작하는 000123과 같은 수로 만들 수 있다.

숫자판이 주어졌을 때, 만들 수 있는 서로 다른 여섯 자리의 수들의 개수를 구하는 프로그램을 작성하시오.

입력
다섯 개의 줄에 다섯 개의 정수로 숫자판이 주어진다.

출력
첫째 줄에 만들 수 있는 수들의 개수를 출력한다.

예시 입력:
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 2 1
1 1 1 1 1

예시 출력:
15

알고리즘 분류:

그래프 이론
브루트포스 알고리즘
그래프 탐색
깊이 우선 탐색

"""

# 숫자를 만들 때, 한 번에 최대 6번 움직일 수 있어요.
# 이동할 때마다 현재 숫자 뒤에 새로운 숫자를 이어 붙여서 만듭니다.

# 만들어진 숫자들은 중복될 수 있어요.
# 이를 위해 set을 사용합니다.

# 숫자판의 모든 칸에서 시작해서 가능한 모든 6자리 숫자를 만듭니다.
# 숫자를 만들 때는 DFS 사용
# 현재 칸에서 네 방향(위, 아래, 왼쪽, 오른쪽)으로 이동합니다.
# 이동한 칸의 숫자를 이어 붙이고, 또 네 방향으로 이동을 반복합니다.
# 여섯 번 움직이면 숫자를 완성하고 멈춥니다.

# 집합에 저장된 숫자들의 개수를 세어서 출력합니다.
# 이 개수가 만들 수 있는 서로 다른 6자리 숫자의 개수입니다.

import sys
input = sys.stdin.readline

# 숫자판 정보 저장
graph = [list(map(int, input().split())) for _ in range(5)]

# 중복된 숫자를 제거하기 위한 집합
unique_numbers = set()

# DFS 탐색 함수
def dfs(x, y, cnt, num):
    """
    x, y: 현재 위치
    cnt: 현재까지 이동 횟수
    num: 현재까지 만든 숫자
    """
    if cnt == 6:  # 여섯 자리 숫자를 완성했을 경우
        unique_numbers.add(num)  # 생성된 숫자를 집합에 추가
        return

    # 네 방향으로 이동
    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nx, ny = x + dx, y + dy  # 새로운 좌표 계산
        # 유효한 범위 내에 있을 경우만 이동
        if 0 <= nx < 5 and 0 <= ny < 5:
            dfs(nx, ny, cnt + 1, num * 10 + graph[nx][ny])  # 다음 칸으로 이동

# 모든 칸에서 탐색 시작
for i in range(5):
    for j in range(5):
        dfs(i, j, 1, graph[i][j])  # 각 칸에서 DFS 시작

# 생성된 숫자의 개수를 출력
print(len(unique_numbers))
